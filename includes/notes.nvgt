void notewriter()
{
form.reset();
form.create_window("NeuroNest", false);
int newdock=form.create_button("Create &note");
int opdock=form.create_button("&Load note");
int quit=form.create_button("&Close app");
form.focus(newdock);
while(true)
{
wait(5);
key_echo_themecheck(form);
form.monitor();
if (key_pressed(KEY_ESCAPE) || form.is_pressed(quit))
{
if (yes_no("Are you sure you want to close the app?"))
exit();
else
notewriter();
}
if(form.is_pressed(newdock))
{
    if (yes_no("Would you like to create an untitled note?"))
    {
        string fullpath = "data/notes/untitled.txt";
        file f;
        if (f.open(fullpath, "wb"))
        {
            f.write("");
            f.close();
            notename = fullpath;
            notetext = "";
            alert("Note created", "Untitled note created at "+fullpath);
            wait(500);
            note_editor();
        }
        else
        {
            alert("Error", "Could not create untitled note.");
            wait(500);
            notewriter();
        }
    }
    else
    {
        vd.set_disallowed_chars("!@#$%^&*()[]{};:'\"\\|,.<>?/+-=`~", false, "This character is not allowed.");
        string nm = vd.input_box("", "Enter the title of this note.");
        if (!nm.empty())
        {
            string fullpath = "data/notes/" + nm + ".txt";
            file f;
            if (f.open(fullpath, "wb"))
            {
                f.write("");
                f.close();
                notename = fullpath;
                notetext = "";
                alert("Note created", "Note created at " + notename);
                wait(500);
                note_editor();
            }
            else
            {
                alert("Error", "Could not create the note at " + fullpath);
                wait(500);
                notewriter();
            }
        }
    }
}
if(form.is_pressed(opdock))
{
string[] files = find_files("data/notes/*.txt");
if (files.length() == 0)
{
alert("No notes found", "There are no notes in data/notes.");
wait(500);
notewriter();
}
else
{
setupmenu();
array<string> displayNames;
for (uint i = 0; i < files.length(); i++)
{
string filename = files[i];
m.add_item(filename);
displayNames.insert_last(filename);
}
m.add_item("Back");
m.intro_text = "Select a note to open.";
int choice = m.run();
if (choice >= 0 && choice < int(files.length()))
{
string path = "data/notes/" + displayNames[choice];
file f;
if (f.open(path, "rb"))
{
notetext = f.read();
f.close();
notename = path;
alert("Note loaded", "Opened " + string_replace(notename, "data/notes/", "", true));
wait(500);
note_editor();
}
else
{
alert("Error", "Failed to read the note at " + path);
wait(500);
notewriter();
}
}
else
{
notewriter();
}
}
}
}
}
void note_editor()
{
form.reset();
form.create_window("note editor", false);
int dockbox = form.create_input_box("&Note text area", notetext, read_only:false, multiline:true, multiline_enter:true);
int infdock=form.create_button("Note &info");
int deldock=form.create_button("&Delete note");
int opdock=form.create_button("&Load note");
int rendock=form.create_button("&Rename note");
int savdock=form.create_button("&Save note");
int savdock2=form.create_button("Save note &as");
int quit=form.create_button("&Close note");
form.focus(dockbox);
while(true)
{
wait(5);
key_echo_themecheck(form);
form.monitor();
notetext=form.get_text(dockbox);
if (key_pressed(KEY_ESCAPE) || form.is_pressed(quit))
{
setupmenu();
m.add_items({"Yes, save it", "No, discard it", "Cancel"});
m.intro_text = "Do you want to save this note before closing it?";
int choice = m.run();
if (choice == 0)
{
file f;
if (f.open(notename, "wb"))
{
f.write(notetext);
f.close();
alert("Saved", "Note saved to " + notename);
}
else
{
alert("Error", "Could not save the note.");
}
wait(500);
notewriter();
}
else if (choice == 1)
{
notewriter();
}
else
{
form.focus(dockbox);
}
}
if (form.is_pressed(infdock))
{
notetext=form.get_text(dockbox);
alert("Note Stats for "+string_replace(notename, "data/notes/", "", true), get_note_charlines(notetext));
wait(500);
form.focus(dockbox);
}
if (form.is_pressed(deldock))
{
    if (yes_no("Are you sure you want to permanently delete this note? This cannot be undone."))
    {
        if (file_exists(notename))
        {
            if (file_delete(notename))
            {
                alert("Deleted", "The note has been deleted.");
                wait(500);
                notewriter();
            }
            else
            {
                alert("Error", "Failed to delete the note.");
                wait(500);
                form.focus(dockbox);
            }
        }
        else
        {
            alert("Error", "The note does not exist.");
            wait(500);
            form.focus(dockbox);
        }
    }
    else
    {
        form.focus(dockbox);
    }
}
if(form.is_pressed(opdock))
{
setupmenu();
m.add_items({"Yes, save it", "No, discard it", "Cancel"});
m.intro_text = "Do you want to save your current note before opening another one?";
int choice = m.run();
bool shouldOpenNew = false;
if (choice == 0)
{
file f;
if (f.open(notename, "wb"))
{
f.write(notetext);
f.close();
alert("Saved", "Note saved to " + notename);
wait(500);
shouldOpenNew = true;
}
else
{
alert("Error", "Could not save the note.");
wait(500);
form.focus(dockbox);
}
}
else if (choice == 1)
{
shouldOpenNew = true;
}
else
{
form.focus(dockbox);
}
if (shouldOpenNew)
{
string[] files = find_files("data/notes/*.txt");
if (files.length() == 0)
{
alert("No notes found", "There are no notes in data/notes.");
wait(500);
form.focus(dockbox);
}
else
{
setupmenu();
array<string> displayNames;
for (uint i = 0; i < files.length(); i++)
{
string filename = files[i];
m.add_item(filename);
displayNames.insert_last(filename);
}
m.add_item("Back");
m.intro_text = "Select a note to open.";
int fileChoice = m.run();
if (fileChoice >= 0 && fileChoice < int(files.length()))
{
string path = "data/notes/" + displayNames[fileChoice];
file f;
if (f.open(path, "rb"))
{
notetext = f.read();
f.close();
notename = path;
alert("Note loaded", "Opened " + string_replace(notename, "data/notes/", "", true));
wait(500);
note_editor();
}
else
{
alert("Error", "Failed to read the note at " + path);
wait(500);
form.focus(dockbox);
}
}
else
{
form.focus(dockbox);
}
}
}
}
if (form.is_pressed(rendock))
{
vd.set_disallowed_chars("!@#$%^&*()[]{};:'\"\\|,.<>?/+-=`~", false, "This character is not allowed.");
string newname = vd.input_box("", "Enter a new name for this note.");
if (!newname.empty())
{
string newpath = "data/notes/" + newname + ".txt";
if (file_exists(newpath))
{
alert("Error", "A note with that name already exists.");
wait(500);
form.focus(dockbox);
}
else
{
string contents = get_file_contents(notename);
if (contents == "")
{
alert("Error", "Could not read from the original note.");
wait(500);
form.focus(dockbox);
}
if (put_file_contents(newpath, contents))
{
if (file_delete(notename))
{
notename = newpath;
alert("Success", "Note renamed to " + newname + ".txt");
wait(500);
form.focus(dockbox);
}
else
{
alert("Partial success", "Copied to new note, but failed to delete original.");
wait(500);
form.focus(dockbox);
}
}
else
{
alert("Error", "Failed to write the new note.");
wait(500);
form.focus(dockbox);
}
}
}
}
if(form.is_pressed(savdock))
{
file f;
if (f.open(notename, "wb"))
{
f.write(notetext);
f.close();
alert("Saved", "Note saved to " + notename);
wait(500);
form.focus(dockbox);
}
else
{
alert("Error", "Could not save the note.");
wait(500);
form.focus(dockbox);
}
}
if (form.is_pressed(savdock2))
{
string newpath = save_file_dialog("Text Files:txt", "data/notes/");
if (!newpath.empty())
{
if (!newpath.lower().ends_with(".txt"))
newpath += ".txt";
file f;
if (f.open(newpath, "wb"))
{
f.write(notetext);
f.close();
notename = newpath;
alert("Saved", "Note saved as " + notename);
wait(500);
form.focus(dockbox);
}
else
{
alert("Error", "Could not save the note.");
wait(500);
form.focus(dockbox);
}
}
}
}
}
